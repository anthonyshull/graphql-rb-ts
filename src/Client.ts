import { useQuery, UseQueryOptions, useMutation, UseMutationOptions } from 'react-query';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };

function fetcher<TData, TVariables>(query: string, variables?: TVariables) {
  return async (): Promise<TData> => {
    const res = await fetch("http://165.227.123.154:3000/graphql", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ query, variables }),
    });
    
    const json = await res.json();

    if (json.errors) {
      const { message } = json.errors[0];

      throw new Error(message);
    }

    return json.data;
  }
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any;
};

/** Autogenerated input type of CreatePurchaseMutation */
export type CreatePurchaseMutationInput = {
  buyerId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  price: Scalars['Float'];
  productId: Scalars['ID'];
  sellerId: Scalars['ID'];
};

/** Autogenerated return type of CreatePurchaseMutation */
export type CreatePurchaseMutationPayload = {
  __typename?: 'CreatePurchaseMutationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Scalars['String']>>;
  purchase?: Maybe<Purchase>;
};


export type Mutation = {
  __typename?: 'Mutation';
  createPurchase: CreatePurchaseMutationPayload;
};


export type MutationCreatePurchaseArgs = {
  input: CreatePurchaseMutationInput;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

export type Product = {
  __typename?: 'Product';
  brand?: Maybe<Scalars['String']>;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  updatedAt: Scalars['ISO8601DateTime'];
};

/** The connection type for Product. */
export type ProductConnection = {
  __typename?: 'ProductConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProductEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Product>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProductEdge = {
  __typename?: 'ProductEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Product>;
};

export type Purchase = {
  __typename?: 'Purchase';
  buyer: User;
  createdAt: Scalars['ISO8601DateTime'];
  id: Scalars['ID'];
  price: Scalars['Float'];
  product?: Maybe<Product>;
  seller: User;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type Query = {
  __typename?: 'Query';
  /** Returns a list of products */
  products?: Maybe<ProductConnection>;
  /** Return a purchase by id */
  purchase: Purchase;
  /** Returns a list of purchases */
  purchases?: Maybe<Array<Purchase>>;
  /** Return a user by id */
  user: User;
  /** Returns a list of users */
  users?: Maybe<Array<User>>;
  /** Returns a list of users sorted by created_at */
  usersSortedByCreatedAt?: Maybe<Array<User>>;
};


export type QueryProductsArgs = {
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
};


export type QueryPurchaseArgs = {
  id: Scalars['ID'];
};


export type QueryUserArgs = {
  id: Scalars['ID'];
};


export type QueryUsersSortedByCreatedAtArgs = {
  direction: Scalars['String'];
};

export type User = {
  __typename?: 'User';
  createdAt: Scalars['ISO8601DateTime'];
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  purchases?: Maybe<Array<Purchase>>;
  stats?: Maybe<UserStats>;
  updatedAt: Scalars['ISO8601DateTime'];
};

export type UserStats = {
  __typename?: 'UserStats';
  boughtFrom: Scalars['Int'];
  soldTo: Scalars['Int'];
};

export type ProductsQueryVariables = Exact<{
  after?: Maybe<Scalars['String']>;
  before?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
}>;


export type ProductsQuery = (
  { __typename?: 'Query' }
  & { products?: Maybe<(
    { __typename?: 'ProductConnection' }
    & { edges?: Maybe<Array<Maybe<(
      { __typename?: 'ProductEdge' }
      & Pick<ProductEdge, 'cursor'>
    )>>>, nodes?: Maybe<Array<Maybe<(
      { __typename?: 'Product' }
      & Pick<Product, 'brand' | 'createdAt' | 'id' | 'name' | 'updatedAt'>
    )>>>, pageInfo: (
      { __typename?: 'PageInfo' }
      & Pick<PageInfo, 'endCursor' | 'hasNextPage' | 'hasPreviousPage' | 'startCursor'>
    ) }
  )> }
);

export type PurchaseQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PurchaseQuery = (
  { __typename?: 'Query' }
  & { purchase: (
    { __typename?: 'Purchase' }
    & Pick<Purchase, 'createdAt' | 'id' | 'price' | 'updatedAt'>
    & { buyer: (
      { __typename?: 'User' }
      & Pick<User, 'createdAt' | 'email' | 'id' | 'name' | 'updatedAt'>
    ), product?: Maybe<(
      { __typename?: 'Product' }
      & Pick<Product, 'brand' | 'createdAt' | 'id' | 'name' | 'updatedAt'>
    )>, seller: (
      { __typename?: 'User' }
      & Pick<User, 'createdAt' | 'email' | 'id' | 'name' | 'updatedAt'>
    ) }
  ) }
);

export type PurchasesQueryVariables = Exact<{ [key: string]: never; }>;


export type PurchasesQuery = (
  { __typename?: 'Query' }
  & { purchases?: Maybe<Array<(
    { __typename?: 'Purchase' }
    & Pick<Purchase, 'createdAt' | 'id' | 'price' | 'updatedAt'>
    & { buyer: (
      { __typename?: 'User' }
      & Pick<User, 'createdAt' | 'email' | 'id' | 'name' | 'updatedAt'>
    ), product?: Maybe<(
      { __typename?: 'Product' }
      & Pick<Product, 'brand' | 'createdAt' | 'id' | 'name' | 'updatedAt'>
    )>, seller: (
      { __typename?: 'User' }
      & Pick<User, 'createdAt' | 'email' | 'id' | 'name' | 'updatedAt'>
    ) }
  )>> }
);

export type UserQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type UserQuery = (
  { __typename?: 'Query' }
  & { user: (
    { __typename?: 'User' }
    & Pick<User, 'createdAt' | 'email' | 'id' | 'name' | 'updatedAt'>
    & { purchases?: Maybe<Array<(
      { __typename?: 'Purchase' }
      & Pick<Purchase, 'createdAt' | 'id' | 'price' | 'updatedAt'>
    )>>, stats?: Maybe<(
      { __typename?: 'UserStats' }
      & Pick<UserStats, 'boughtFrom' | 'soldTo'>
    )> }
  ) }
);

export type UsersQueryVariables = Exact<{ [key: string]: never; }>;


export type UsersQuery = (
  { __typename?: 'Query' }
  & { users?: Maybe<Array<(
    { __typename?: 'User' }
    & Pick<User, 'createdAt' | 'email' | 'id' | 'name' | 'updatedAt'>
    & { purchases?: Maybe<Array<(
      { __typename?: 'Purchase' }
      & Pick<Purchase, 'createdAt' | 'id' | 'price' | 'updatedAt'>
    )>>, stats?: Maybe<(
      { __typename?: 'UserStats' }
      & Pick<UserStats, 'boughtFrom' | 'soldTo'>
    )> }
  )>> }
);

export type UsersSortedByCreatedAtQueryVariables = Exact<{
  direction: Scalars['String'];
}>;


export type UsersSortedByCreatedAtQuery = (
  { __typename?: 'Query' }
  & { usersSortedByCreatedAt?: Maybe<Array<(
    { __typename?: 'User' }
    & Pick<User, 'createdAt' | 'email' | 'id' | 'name' | 'updatedAt'>
    & { purchases?: Maybe<Array<(
      { __typename?: 'Purchase' }
      & Pick<Purchase, 'createdAt' | 'id' | 'price' | 'updatedAt'>
    )>>, stats?: Maybe<(
      { __typename?: 'UserStats' }
      & Pick<UserStats, 'boughtFrom' | 'soldTo'>
    )> }
  )>> }
);

export type CreatePurchaseMutationVariables = Exact<{
  input: CreatePurchaseMutationInput;
}>;


export type CreatePurchaseMutation = (
  { __typename?: 'Mutation' }
  & { createPurchase: (
    { __typename?: 'CreatePurchaseMutationPayload' }
    & Pick<CreatePurchaseMutationPayload, 'clientMutationId' | 'errors'>
    & { purchase?: Maybe<(
      { __typename?: 'Purchase' }
      & Pick<Purchase, 'createdAt' | 'id' | 'price' | 'updatedAt'>
    )> }
  ) }
);


export const ProductsDocument = `
    query Products($after: String, $before: String, $first: Int, $last: Int) {
  products(after: $after, before: $before, first: $first, last: $last) {
    edges {
      cursor
    }
    nodes {
      brand
      createdAt
      id
      name
      updatedAt
    }
    pageInfo {
      endCursor
      hasNextPage
      hasPreviousPage
      startCursor
    }
  }
}
    `;
export const useProductsQuery = <
      TData = ProductsQuery,
      TError = unknown
    >(
      variables?: ProductsQueryVariables, 
      options?: UseQueryOptions<ProductsQuery, TError, TData>
    ) => 
    useQuery<ProductsQuery, TError, TData>(
      ['Products', variables],
      fetcher<ProductsQuery, ProductsQueryVariables>(ProductsDocument, variables),
      options
    );
export const PurchaseDocument = `
    query Purchase($id: ID!) {
  purchase(id: $id) {
    buyer {
      createdAt
      email
      id
      name
      updatedAt
    }
    createdAt
    id
    price
    product {
      brand
      createdAt
      id
      name
      updatedAt
    }
    seller {
      createdAt
      email
      id
      name
      updatedAt
    }
    updatedAt
  }
}
    `;
export const usePurchaseQuery = <
      TData = PurchaseQuery,
      TError = unknown
    >(
      variables: PurchaseQueryVariables, 
      options?: UseQueryOptions<PurchaseQuery, TError, TData>
    ) => 
    useQuery<PurchaseQuery, TError, TData>(
      ['Purchase', variables],
      fetcher<PurchaseQuery, PurchaseQueryVariables>(PurchaseDocument, variables),
      options
    );
export const PurchasesDocument = `
    query Purchases {
  purchases {
    buyer {
      createdAt
      email
      id
      name
      updatedAt
    }
    createdAt
    id
    price
    product {
      brand
      createdAt
      id
      name
      updatedAt
    }
    seller {
      createdAt
      email
      id
      name
      updatedAt
    }
    updatedAt
  }
}
    `;
export const usePurchasesQuery = <
      TData = PurchasesQuery,
      TError = unknown
    >(
      variables?: PurchasesQueryVariables, 
      options?: UseQueryOptions<PurchasesQuery, TError, TData>
    ) => 
    useQuery<PurchasesQuery, TError, TData>(
      ['Purchases', variables],
      fetcher<PurchasesQuery, PurchasesQueryVariables>(PurchasesDocument, variables),
      options
    );
export const UserDocument = `
    query User($id: ID!) {
  user(id: $id) {
    createdAt
    email
    id
    name
    purchases {
      createdAt
      id
      price
      updatedAt
    }
    stats {
      boughtFrom
      soldTo
    }
    updatedAt
  }
}
    `;
export const useUserQuery = <
      TData = UserQuery,
      TError = unknown
    >(
      variables: UserQueryVariables, 
      options?: UseQueryOptions<UserQuery, TError, TData>
    ) => 
    useQuery<UserQuery, TError, TData>(
      ['User', variables],
      fetcher<UserQuery, UserQueryVariables>(UserDocument, variables),
      options
    );
export const UsersDocument = `
    query Users {
  users {
    createdAt
    email
    id
    name
    purchases {
      createdAt
      id
      price
      updatedAt
    }
    stats {
      boughtFrom
      soldTo
    }
    updatedAt
  }
}
    `;
export const useUsersQuery = <
      TData = UsersQuery,
      TError = unknown
    >(
      variables?: UsersQueryVariables, 
      options?: UseQueryOptions<UsersQuery, TError, TData>
    ) => 
    useQuery<UsersQuery, TError, TData>(
      ['Users', variables],
      fetcher<UsersQuery, UsersQueryVariables>(UsersDocument, variables),
      options
    );
export const UsersSortedByCreatedAtDocument = `
    query UsersSortedByCreatedAt($direction: String!) {
  usersSortedByCreatedAt(direction: $direction) {
    createdAt
    email
    id
    name
    purchases {
      createdAt
      id
      price
      updatedAt
    }
    stats {
      boughtFrom
      soldTo
    }
    updatedAt
  }
}
    `;
export const useUsersSortedByCreatedAtQuery = <
      TData = UsersSortedByCreatedAtQuery,
      TError = unknown
    >(
      variables: UsersSortedByCreatedAtQueryVariables, 
      options?: UseQueryOptions<UsersSortedByCreatedAtQuery, TError, TData>
    ) => 
    useQuery<UsersSortedByCreatedAtQuery, TError, TData>(
      ['UsersSortedByCreatedAt', variables],
      fetcher<UsersSortedByCreatedAtQuery, UsersSortedByCreatedAtQueryVariables>(UsersSortedByCreatedAtDocument, variables),
      options
    );
export const CreatePurchaseDocument = `
    mutation CreatePurchase($input: CreatePurchaseMutationInput!) {
  createPurchase(input: $input) {
    clientMutationId
    errors
    purchase {
      createdAt
      id
      price
      updatedAt
    }
  }
}
    `;
export const useCreatePurchaseMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<CreatePurchaseMutation, TError, CreatePurchaseMutationVariables, TContext>) => 
    useMutation<CreatePurchaseMutation, TError, CreatePurchaseMutationVariables, TContext>(
      (variables?: CreatePurchaseMutationVariables) => fetcher<CreatePurchaseMutation, CreatePurchaseMutationVariables>(CreatePurchaseDocument, variables)(),
      options
    );